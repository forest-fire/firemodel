import { SerializedQuery } from "serialized-query";
import { debounce } from "lodash";
import { rtdb } from "firebase-api-surface";
import { Record } from "./Record";
import { FMEvents } from "./state-mgmt";
//#region generalized structures

export type ChildEventCallback = (snap: any, previous?: string) => void;
export type Dispatcher = (args: any[]) => void;

export interface IFMAction {
  type: FMEvents;
  payload: any;
  model: string;
  [key: string]: any;
}

export interface IFMChildAction extends IFMAction {
  key: string;
  prevKey: string;
  path: string;
  query: SerializedQuery | null;
}

export interface IFMValueAction extends IFMAction {
  model: string;
  query: SerializedQuery | null;
}

export interface IFMStartListening extends IFMAction {
  query: SerializedQuery;
  dbPath: string;
  localPath: string;
}
//#endregion

//#region specific events
/**
 *
 * @param model The model which will be listened for
 * @param ref The reference / serialized query which the streams will be setup on
 * @param dispatch The callback function which is called
 */
export async function modelListener<T>(
  model: Record<T>,
  query: SerializedQuery<T>,
  dispatch = defaultDispatcher
) {
  dispatch({
    type: FMActions.MODEL_START_LISTENING,
    model: model.modelName,
    query,
    dbPath: model.dbPath,
    localPath: model.localPath,
    payload: null
  });

  // const map = new RelationshipMap();

  const child_added = childEvent<T>("child_added", model, dispatch);
  const child_moved = childEvent<T>("child_moved", model, dispatch);
  const child_removed = childEvent<T>("child_removed", model, dispatch);
  const child_changed = childEvent<T>("child_changed", model, dispatch);

  query
    .deserialize()
    .on("child_added", model_ready(child_added, model, dispatch));
  query.deserialize().on("child_moved", child_moved);
  query.deserialize().on("child_removed", child_removed);
  query.deserialize().on("child_changed", child_changed);
}

const model_ready = (
  child_added: ChildEventCallback,
  model: Record<any>,
  dispatch = defaultDispatcher
) => {
  const started = new Date().getTime();
  const assumedTimeLimit = 100;
  // let last: number;
  let ready = false;
  return (...args: any[]) => {
    const returnVal = child_added(args);
    if (!ready) {
      const now = new Date().getTime();
      debounce(
        () => {
          ready = true;
          dispatch({
            type: FMActions.MODEL_STATE_READY,
            model: model.modelName,
            started,
            duration: started - now
          });
        },
        assumedTimeLimit,
        {}
      );
    }
    return returnVal;
  };
};

const relationshipChanges = <T>(eventType: string) => {
  switch (eventType) {
    case "child_added":
  }
};

export function recordListener<T>() {
  //
}

export function defaultDispatcher<T = IFMAction>(action: T): any {
  return action;
}

export const childEvent = <T>(
  eventType: rtdb.EventType,
  model: Record<any>,
  dispatch = defaultDispatcher
) => (snap: any, previous?: string) => {
  const action: IFMChildAction = {
    type: FMActions.RECORD_ADDED,
    key: snap.key,
    prevKey: previous,
    path: model.dbPath,
    model: model.modelName,
    query: null,
    payload: snap.val() as T
  };

  dispatch(action);
  if (eventType !== "child_moved") {
    relationshipChanges<T>(eventType);
  }
};

//#endregion
